<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Change of Perceptions</title>
<meta name="keywords" content="" />
<meta name="description" content="WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.
소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다
여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.
Login 로그인 방식은 서버 세션으로 구현했습니다.
HttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다.">
<meta name="author" content="">
<link rel="canonical" href="https://2012monk.github.io/monk/til/websocket-%EC%9C%BC%EB%A1%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/" />
<link crossorigin="anonymous" href="/monk/assets/css/stylesheet.min.65aebb33e4f0ce3d1a39e4a35c11b91eb08b582489fca0f78f9227d90ac72a52.css" integrity="sha256-Za67M&#43;Twzj0aOeSjXBG5HrCLWCSJ/KD3j5In2QrHKlI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/monk/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://2012monk.github.io/monk/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://2012monk.github.io/monk/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://2012monk.github.io/monk/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://2012monk.github.io/monk/apple-touch-icon.png">
<link rel="mask-icon" href="https://2012monk.github.io/monk/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.82.1" />
<meta property="og:title" content="" />
<meta property="og:description" content="WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.
소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다
여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.
Login 로그인 방식은 서버 세션으로 구현했습니다.
HttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://2012monk.github.io/monk/til/websocket-%EC%9C%BC%EB%A1%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/" /><meta property="article:section" content="TIL" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.
소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다
여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.
Login 로그인 방식은 서버 세션으로 구현했습니다.
HttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "TILs",
      "item": "https://2012monk.github.io/monk/til/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "",
      "item": "https://2012monk.github.io/monk/til/websocket-%EC%9C%BC%EB%A1%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.\n소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다\n여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.\nLogin 로그인 방식은 서버 세션으로 구현했습니다.\nHttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다.",
  "keywords": [
    
  ],
  "articleBody": "WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.\n소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다\n여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.\nLogin 로그인 방식은 서버 세션으로 구현했습니다.\nHttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다.\n페이지 권한은 Filter 에서 직접 세션 아이디를 확인 하는 방식으로 인증되지 않았으면 login 페이지로 돌려보냅니다.\nChat server structure Web socket endpoint 에서 직접 user session 을 관리하여 메시징합니다.\nWebsocket Session 은 HttpSession 의 세션 정보로 식별하여 관리합니다.\nPrivate message 의 방식은 클라이언트에서 받은 메시지를 id로 식별하여 양쪽에 다보내주는 방식이고\nRomm message 는 Room 객체에서 각각의 user id 를 관리함으로써 식별하여 메세징 하는 방식입니다.\n",
  "wordCount" : "137",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://2012monk.github.io/monk/til/websocket-%EC%9C%BC%EB%A1%9C-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Change of Perceptions",
    "logo": {
      "@type": "ImageObject",
      "url": "https://2012monk.github.io/monk/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://2012monk.github.io/monk" accesskey="h" title="Change of Perceptions (Alt + H)">Change of Perceptions</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://2012monk.github.io/monk/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://2012monk.github.io/monk/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">
</div>
  </header> 
  <div class="post-content"><h2 id="websocket-으로-구현한-채팅">WebSocket 으로 구현한 채팅<a hidden class="anchor" aria-hidden="true" href="#websocket-으로-구현한-채팅">#</a></h2>
<hr>
<ul>
<li>chat</li>
<li>Private chat</li>
<li>Room chat</li>
<li>login</li>
<li>Add friend</li>
</ul>
<hr>
<p>Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.</p>
<p>소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다</p>
<p>여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.</p>
<h3 id="login">Login<a hidden class="anchor" aria-hidden="true" href="#login">#</a></h3>
<p>로그인 방식은 서버 세션으로 구현했습니다.</p>
<p>HttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다.</p>
<p>페이지 권한은 Filter 에서 직접 세션 아이디를 확인 하는 방식으로 인증되지 않았으면 login 페이지로 돌려보냅니다.</p>
<h3 id="chat-server-structure">Chat server structure<a hidden class="anchor" aria-hidden="true" href="#chat-server-structure">#</a></h3>
<p>Web socket endpoint 에서 직접 user session 을 관리하여 메시징합니다.</p>
<p>Websocket Session 은 HttpSession 의 세션 정보로 식별하여 관리합니다.</p>
<p>Private message 의 방식은 클라이언트에서 받은 메시지를 id로 식별하여 양쪽에 다보내주는 방식이고</p>
<p>Romm message 는 Room 객체에서 각각의 user id 를 관리함으로써 식별하여 메세징 하는 방식입니다.</p>

</div>
  <footer class="post-footer">
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://2012monk.github.io/monk">Change of Perceptions</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
