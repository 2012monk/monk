<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Change of Perceptions</title><meta name=keywords content><meta name=description content="Thread  Process & Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위
 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태
프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태
 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스
시스템 자원
 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.
 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다."><meta name=author content><link rel=canonical href=https://2012monk.github.io/monk/til/java/thread/><link crossorigin=anonymous href=/monk/assets/css/stylesheet.min.65aebb33e4f0ce3d1a39e4a35c11b91eb08b582489fca0f78f9227d90ac72a52.css integrity="sha256-Za67M+Twzj0aOeSjXBG5HrCLWCSJ/KD3j5In2QrHKlI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/monk/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://2012monk.github.io/monk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2012monk.github.io/monk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2012monk.github.io/monk/favicon-32x32.png><link rel=apple-touch-icon href=https://2012monk.github.io/monk/apple-touch-icon.png><link rel=mask-icon href=https://2012monk.github.io/monk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content><meta property="og:description" content="Thread  Process & Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위
 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태
프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태
 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스
시스템 자원
 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.
 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다."><meta property="og:type" content="article"><meta property="og:url" content="https://2012monk.github.io/monk/til/java/thread/"><meta property="article:section" content="TIL"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Thread  Process & Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위
 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태
프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태
 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스
시스템 자원
 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.
 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"TILs","item":"https://2012monk.github.io/monk/til/"},{"@type":"ListItem","position":3,"name":"","item":"https://2012monk.github.io/monk/til/java/thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Thread  Process \u0026amp; Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위\n 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태\n프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태\n 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스\n시스템 자원\n 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.\n 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다.","keywords":[],"articleBody":"Thread  Process \u0026 Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위\n 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태\n프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태\n 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스\n시스템 자원\n 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.\n 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다.\n프로세스 끼리 접근기위해 서는 프로세스간의 통신을 이용해야한다.\n IPC (inter-process-communication) LPC(Local inter-Process communication) 파이프, 파일, 소켓등    Thread  프로세스 내에서 실행되는 흐름의 단위 CPU의 최소 작업 단위\n프로세스의 특정한 수행경로\n프로세스는 하나의 스레드 메인스레드를` 가지고 있다\n하나의 프로세스는 여러 개의 스레드를 가질수 있다 멀티스레드\n쓰레드는 프로세스 내에 Code, Data, Heap 영역은 공유하고 Stack만 따로 할당받는다. 서로의 자원에 접근할수 있다\n Multi process  하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 태스크를 처리하도록 하는것\n독립된 구조로 실행되기에 각 프로세스가 서로 영향을 주지않아 안전성이 높다\n각각 독립된 메모리 영역을 가지고 있어, 작업량이 많을수록 오버헤드가 발생한다, Context Switching으로 인한 성능저하가 발생한다.\nOverHead 어떤 처리를 하기위해 들어가는 간접적인 처리 시간, 메모리 목적달성에 본질적이진 않지만 필요한 자원\nContext Switching CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정\n동작 중인 프로세스가 대기를 하면서 프로세스의 상태 context를 보관하고, 대기하고있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업.\n Multi Thread  하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는것.\n 프로세스를 생성하여 자원할당하는 시스템 콜이 줄어들어 자원효율성이 증대된다. 스레드 간에 데이터를 주고받는게 간단해져 통신의 부담이 적고 (메모리 공유) 시스템 자원 소모가 줄어든다 Context Switching이 빠르다 context switching시 스레드는 stack만 처리하기 때문    하지만 주의 깊은 설계가 필요하고 디버깅이 까다롭다.\n  단일 프로세스 시스템일 경우에는 효과를 보기 힘들다.\n  하나의 스레드에 문제가발생하면 전체 프로세스가 영향을받는다\n  멀티 스레드의 경우에 자원 공유의 문제가 발생한다 동기화 문제 synchronization issue\n 각각의 스레드가 어떤순서로 실행될 지 순서를 알수없다. 스케줄링은 os가 자동으로 해주지 않기에 신중하게 설계해야한다.     ","wordCount":"301","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://2012monk.github.io/monk/til/java/thread/"},"publisher":{"@type":"Organization","name":"Change of Perceptions","logo":{"@type":"ImageObject","url":"https://2012monk.github.io/monk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://2012monk.github.io/monk accesskey=h title="Change of Perceptions (Alt + H)">Change of Perceptions</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://2012monk.github.io/monk/categories/ title=categories><span>categories</span></a></li><li><a href=https://2012monk.github.io/monk/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title></h1><div class=post-meta></div></header><div class=post-content><h3 id=thread>Thread<a hidden class=anchor aria-hidden=true href=#thread>#</a></h3><hr><h5 id=process--thread>Process & Thread<a hidden class=anchor aria-hidden=true href=#process--thread>#</a></h5><h6 id=process>Process<a hidden class=anchor aria-hidden=true href=#process>#</a></h6><blockquote><p><em>컴퓨터에서 연속적으로 실행되고 있는 프로그램</em> <code>운영체제의 최소 작업 단위</code></p><blockquote><p><code>프로그램</code> 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태</p><p><code>프로세스</code> 프로그램이 실행되어 메모리에 올라간 동적인 상태</p></blockquote><p><em>프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다</em> <code>프로그램의 인스턴스</code></p><p>시스템 자원</p><ul><li>독립된 메모리공간</li><li>cpu시간</li><li>운영되기 위해 필요한 메모리 주소</li></ul><p>프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.</p><blockquote><p>운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다.</p><p>프로세스 끼리 접근기위해 서는 프로세스간의 통신을 이용해야한다.</p><ul><li>IPC (inter-process-communication)</li><li>LPC(Local inter-Process communication)</li><li>파이프, 파일, 소켓등</li></ul></blockquote></blockquote><h6 id=thread-1>Thread<a hidden class=anchor aria-hidden=true href=#thread-1>#</a></h6><blockquote><p><em>프로세스 내에서 실행되는 흐름의 단위</em> <code>CPU의 최소 작업 단위</code></p><p><em>프로세스의 특정한 수행경로</em></p><p><em>프로세스는 하나의 스레드 <code>메인스레드</code>를` 가지고 있다</em></p><p><em>하나의 프로세스는 여러 개의 스레드를 가질수 있다</em> <code>멀티스레드</code></p><p>쓰레드는 프로세스 내에 Code, Data, Heap 영역은 공유하고 Stack만 따로 할당받는다. <em>서로의 자원에 접근할수 있다</em></p></blockquote><h5 id=multi-process>Multi process<a hidden class=anchor aria-hidden=true href=#multi-process>#</a></h5><blockquote><p><em>하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 태스크를 처리하도록 하는것</em></p><p>독립된 구조로 실행되기에 각 프로세스가 서로 영향을 주지않아 안전성이 높다</p><p>각각 독립된 메모리 영역을 가지고 있어, 작업량이 많을수록 오버헤드가 발생한다, Context Switching으로 인한 성능저하가 발생한다.</p><p><code>OverHead</code> 어떤 처리를 하기위해 들어가는 간접적인 처리 시간, 메모리 <em>목적달성에 본질적이진 않지만 필요한 자원</em></p><p><code>Context Switching</code> <em>CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정</em></p><p><em>동작 중인 프로세스가 대기를 하면서 프로세스의 상태 <code>context</code>를 보관하고, 대기하고있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업.</em></p></blockquote><h5 id=multi-thread>Multi Thread<a hidden class=anchor aria-hidden=true href=#multi-thread>#</a></h5><blockquote><p>하나의 응용프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는것.</p><ul><li>프로세스를 생성하여 자원할당하는 시스템 콜이 줄어들어 자원효율성이 증대된다.</li><li>스레드 간에 데이터를 주고받는게 간단해져 통신의 부담이 적고 (메모리 공유) 시스템 자원 소모가 줄어든다</li><li>Context Switching이 빠르다 <em>context switching시 스레드는 stack만 처리하기 때문</em></li></ul><ul><li><p>하지만 주의 깊은 설계가 필요하고 디버깅이 까다롭다.</p></li><li><p>단일 프로세스 시스템일 경우에는 효과를 보기 힘들다.</p></li><li><p>하나의 스레드에 문제가발생하면 전체 프로세스가 영향을받는다</p></li><li><p>멀티 스레드의 경우에 자원 공유의 문제가 발생한다 동기화 문제 <code>synchronization issue</code></p><ul><li>각각의 스레드가 어떤순서로 실행될 지 순서를 알수없다.</li><li>스케줄링은 os가 자동으로 해주지 않기에 신중하게 설계해야한다.</li></ul></li></ul></blockquote></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://2012monk.github.io/monk>Change of Perceptions</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>