<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Change of Perceptions</title>
<meta name="keywords" content="" />
<meta name="description" content="WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다
Stateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다
 HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다.">
<meta name="author" content="">
<link rel="canonical" href="https://2012monk.github.io/monk/til/web/websocket/" />
<link crossorigin="anonymous" href="/monk/assets/css/stylesheet.min.65aebb33e4f0ce3d1a39e4a35c11b91eb08b582489fca0f78f9227d90ac72a52.css" integrity="sha256-Za67M&#43;Twzj0aOeSjXBG5HrCLWCSJ/KD3j5In2QrHKlI=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/monk/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://2012monk.github.io/monk/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://2012monk.github.io/monk/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://2012monk.github.io/monk/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://2012monk.github.io/monk/apple-touch-icon.png">
<link rel="mask-icon" href="https://2012monk.github.io/monk/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.82.1" />
<meta property="og:title" content="" />
<meta property="og:description" content="WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다
Stateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다
 HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://2012monk.github.io/monk/til/web/websocket/" /><meta property="article:section" content="TIL" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다
Stateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다
 HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "TILs",
      "item": "https://2012monk.github.io/monk/til/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "",
      "item": "https://2012monk.github.io/monk/til/web/websocket/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다\nStateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다\n HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다.",
  "keywords": [
    
  ],
  "articleBody": "WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다\nStateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다\n HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다.\n이러한 문제를 해결하기 위하여 Polling, Long Polling 등의 방식이 나왔다.\n Polling   polling 이란 하나의 장치가 다른 장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할때 송수신 등의 자료처리를 하는것\n클라이언트측에서 주기적인 요청을 만들어 서버로 보냄으로써 서버와 데이터 동기화를 유지한다\n 요청에 대한 연결을 만드는 것이 자원이 많이 소모된다 너무 긴 주기는 실시간 사용자 경험을 제공하기 힘들다 너무 짧은 주기는 많은 서버 자원이 소모된다     Long Polling\n 이러한 polling 방식의 단점을 극복하기 위해 만들어진 방식\n서버측 접속을 열어두는 시간을 길게하는 방식\n클라이언트가 요청을 보냈을때 서버는 보낼 메세지가 생기기 전까지 응답을 하지 않는다.\n메세지가 생기면 서버는 응답한다.\n클라이언트는 응답을 받은 즉시 요청을 보낸다.\nㄹ\n 불필요한 요청에 응답하지 않음으로 커넥션 수립 자원에 대한 비용을 줄일수 있다 연결을 유지하고 있는 과정에 대한 비용발생 다수의 이벤트가 동시에 발생시 응답과 요청이 바로 이루어지기에 순간적인 부하     WebSocket Protocol 이전의 방식들은 진정한 실시간 연결을 구현하는데 문제가 있었고 이로 인해 HTML 5 표준안의 일부로 websocket API 이 등장하였다.\nWeb socket 방식은 실시간 양방향 통신 bi-directional full duplex communication 을 지원하며 한번 연결이 수립되면 클라이언트와 서버 모두 자유롭게 데이터를 보낼수있다.\nPolling 같은 반이중 방식_Half duplex communications_ 에 디해 더 낮은 부하를 사용한다.\nWeb socket 은 2011년 RFC 6455에 의해 표준화 되었고, 현재 대부분 브라우저에서 지원한다.\nWeb socket URI Scheme ws://, wss:// for SSL\nwebsocket 은 OSI 7계층에 위치해 있으며 TCP / IP 위에서 동작하는 protocol 이다. 80, 443 포트위에서 동작하도록 설계되었으며 HTTP프록시 및 중간 층을 지원하도록 설계되었으므로 HTTP 프로토콜과 호환이 된다.\nHTTP 를 이용하여 연결을 수립하며 이후에도 80 , 443 포트를 이용해 연결을 유지한다.\nProtocol 과정 Protocol Handshake Handshake Request Web socket 연결을 위해 클라이언트는 웹소켓 handshake 요청을 보낸다.\nHandshake 과정은 HTTP 를 바탕으로 이루어진다.\n일반적인 HTTP status code 는 handshake 이전에만 이용된다.\nGET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com 클라이언트는 “Upgrade”,“Connection” 헤더를 통해 웹소켓 프로토콜을 요청한다.\nOrigin 헤더로 CORS 인증 요청.\n서버가 web socket 버전 인식을 실패할 경우 Sec-WebSocket-Version 요청을 보내야 한다.\nSec-WebSocket-Key 헤더를 통해 응답을 검증할 키 값을 보낸다.\nHandshake Response 요청을 받은 서버는 아래와 같은 응답을 보내주어야 한다.\nHTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Http Status code 101 Switching Protocols\nUpgrade 헤더를 통해 요청한 것에 따라 서버가 프로토콜을 바꾼다는 것을 알려주는 응답 코드\n서버는 반드시 Sec-WebSocket-Accept 헤더를 명시해서 보내야한다.\n클라이언트의 key 값과 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” magic string 을 함께\nSHA-1 hash 함수로 hashing 한뒤 bash64 로 해쉬값을 인코딩해서 응답을 보낸다\n핸드 쉐이크 과정이 끝나면 클라이언트와 서버는 실시간으로 연결된다\nData Frame Exchange 서버와 클라이언트는 data frame 을 통해 데이터를 주고받는다, data frame 은 XOR encryption 으로 마스킹 된다.\n데이터 프레임은 아래 구조를 따른다.\nData Frame Format  0 1 2 3 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len | Extended payload length | |I|S|S|S| (4) |A| (7) | (16/64) | |N|V|V|V| |S| | (if payload len==126/127) | | |1|2|3| |K| | | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + 4 5 6 7 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Extended payload length continued, if payload len == 127 | + - - - - - - - - - - - - - - - +-------------------------------+ 8 9 10 11 + - - - - - - - - - - - - - - - +-------------------------------+ | |Masking-key, if MASK set to 1 | +-------------------------------+-------------------------------+ 12 13 14 15 +-------------------------------+-------------------------------+ | Masking-key (continued) | Payload Data | +-------------------------------- - - - - - - - - - - - - - - - + : Payload Data continued ... : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + | Payload Data continued ... | +---------------------------------------------------------------+ MASK 비트는 메세지가 인코딩 되어있는지 여부를 나타내고, 클라이언트 가 서버에게 보내는 메세지는 항상 마스킹 되어야한다.\n서버가 클라이언트에게 보내는 메세지는 항상 마스킹되어 있지 않아야한다 MASK field 0\nopcode 핖드는 payload 데이터가 어떤 포맷인지 나타낸다.\n0x0 continuation, 0x1 text (UTF-8), 0x2 binary\n0x3 / 0x7 / 0xB~0xF 의 값은 아무런 의미가 없다.\nFIN 비트는 이 메세지가 마지막임을 나타낸다.\nPayload 9~15 번 7bit 까지를 읽어 unsigned integer로 취급한 뒤 125이하이면 payload length\n126 이면 다음 16 bit 를 읽어 unsigned integer로 처리하고 payload length값으로 사용.\n127이면 이면 다음 64bit 를 읽어 unsigned integer로 처리하고 payload length값 으로 사용 최상위 비트는 반드시 0\nMASK MASK 비트가 설정되어 있으면 32bit 길이의 Masking-key도 존재한다\nMasking-key length 0 or 4 bytes\nMASK bit가 1이면 다음 32bit 를 읽는다.\n원본 Payload data를 Making-key 의 필드와 MASK[ i % 4] 에 해당하는 1바이트와 XOR 연산을 수행한다.\nbyte[] MASK = new byte[4]; byte[] ENCODED = new byte[payload.legnth]; byte[] DECODED = new byte[ENCODED.length]; for (int i=0;iENCODED.length; i++){ DECODED[i] = ENCODED[i] ^ MASK[i%4] } ",
  "wordCount" : "901",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://2012monk.github.io/monk/til/web/websocket/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Change of Perceptions",
    "logo": {
      "@type": "ImageObject",
      "url": "https://2012monk.github.io/monk/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://2012monk.github.io/monk" accesskey="h" title="Change of Perceptions (Alt + H)">Change of Perceptions</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://2012monk.github.io/monk/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://2012monk.github.io/monk/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">
</div>
  </header> 
  <div class="post-content"><h2 id="websocket">WebSocket<a hidden class="anchor" aria-hidden="true" href="#websocket">#</a></h2>
<hr>
<h4 id="http-protocol">HTTP protocol<a hidden class="anchor" aria-hidden="true" href="#http-protocol">#</a></h4>
<blockquote>
<p>HTTP 프로토콜은 request, response 라는 message에 의해 성립된다</p>
<p>Stateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다</p>
</blockquote>
<p>HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의  수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 <em>(이러한 과정은 자원이 많이 소모된다</em> ) 하는 비효율성에 대한 문제가 있었다.</p>
<p>이러한 문제를 해결하기 위하여 Polling, Long Polling 등의 방식이 나왔다.</p>
<ul>
<li>Polling</li>
</ul>
<blockquote>
<p><em>polling 이란 하나의 장치가 다른 장치의 상태를 주기적으로 검사하여 일정한 조건을 만족할때 송수신 등의 자료처리를 하는것</em></p>
<p>클라이언트측에서 주기적인 요청을 만들어 서버로 보냄으로써 서버와 데이터 동기화를 유지한다</p>
<ul>
<li>요청에 대한 연결을 만드는 것이 자원이 많이 소모된다</li>
<li>너무 긴 주기는 실시간 사용자 경험을 제공하기 힘들다</li>
<li>너무 짧은 주기는 많은 서버 자원이 소모된다</li>
</ul>
</blockquote>
<ul>
<li>
<p>Long Polling</p>
<blockquote>
<p>이러한 polling 방식의 단점을 극복하기 위해 만들어진 방식</p>
<p>서버측 접속을 열어두는 시간을 길게하는 방식</p>
<p>클라이언트가 요청을 보냈을때 서버는 보낼 메세지가 생기기 전까지 응답을 하지 않는다.</p>
<p>메세지가 생기면 서버는 응답한다.</p>
<p>클라이언트는 응답을 받은 즉시 요청을 보낸다.</p>
<p>ㄹ</p>
<ul>
<li>불필요한 요청에 응답하지 않음으로 커넥션 수립 자원에 대한 비용을 줄일수 있다</li>
<li>연결을 유지하고 있는 과정에 대한 비용발생</li>
<li>다수의 이벤트가 동시에 발생시 응답과 요청이 바로 이루어지기에 순간적인 부하</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="websocket-protocol">WebSocket Protocol<a hidden class="anchor" aria-hidden="true" href="#websocket-protocol">#</a></h3>
<p>이전의 방식들은 진정한 실시간 연결을 구현하는데 문제가 있었고 이로 인해 HTML 5 표준안의 일부로  websocket API 이 등장하였다.</p>
<p>Web socket 방식은 실시간 양방향 통신 <em>bi-directional full duplex communication</em> 을 지원하며 한번 연결이 수립되면 클라이언트와 서버 모두 자유롭게 데이터를 보낼수있다.</p>
<p>Polling 같은 반이중 방식_Half duplex communications_ 에 디해 더 낮은 부하를 사용한다.</p>
<p>Web socket 은 2011년 <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>에 의해 표준화 되었고, 현재 대부분 브라우저에서 지원한다.</p>
<p>Web socket URI Scheme <code>ws://</code>, <code>wss://</code> for <em>SSL</em></p>
<p>websocket 은  OSI 7계층에 위치해 있으며  TCP / IP 위에서 동작하는 protocol 이다. 80, 443 포트위에서 동작하도록 설계되었으며 HTTP프록시 및 중간 층을 지원하도록 설계되었으므로 HTTP 프로토콜과 호환이 된다.</p>
<p>HTTP 를 이용하여 연결을 수립하며 이후에도 80 , 443 포트를 이용해 연결을 유지한다.</p>
<h4 id="protocol-과정">Protocol 과정<a hidden class="anchor" aria-hidden="true" href="#protocol-과정">#</a></h4>
<h4 id="protocol-handshake">Protocol Handshake<a hidden class="anchor" aria-hidden="true" href="#protocol-handshake">#</a></h4>
<h5 id="handshake-request">Handshake Request<a hidden class="anchor" aria-hidden="true" href="#handshake-request">#</a></h5>
<p>Web socket 연결을 위해 클라이언트는 웹소켓 handshake  요청을 보낸다.</p>
<p>Handshake 과정은 HTTP 를 바탕으로 이루어진다.</p>
<p>일반적인 HTTP status code 는 handshake 이전에만 이용된다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-HTTP" data-lang="HTTP"><span style="color:#a6e22e">GET</span> /chat <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">server.example.com</span>
Upgrade<span style="color:#f92672">:</span> <span style="color:#ae81ff">websocket</span>
Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">Upgrade</span>
Sec-WebSocket-Key<span style="color:#f92672">:</span> <span style="color:#ae81ff">x3JJHMbDL1EzLkh9GBhXDw==</span>
Sec-WebSocket-Protocol<span style="color:#f92672">:</span> <span style="color:#ae81ff">chat, superchat</span>
Sec-WebSocket-Version<span style="color:#f92672">:</span> <span style="color:#ae81ff">13</span>
Origin<span style="color:#f92672">:</span> <span style="color:#ae81ff">http://example.com</span>
</code></pre></div><p>클라이언트는 &ldquo;Upgrade&rdquo;,&ldquo;Connection&rdquo; 헤더를 통해 웹소켓 프로토콜을 요청한다.</p>
<p>Origin 헤더로  CORS  인증 요청.</p>
<p>서버가 web socket 버전 인식을 실패할 경우 Sec-WebSocket-Version 요청을 보내야 한다.</p>
<p>Sec-WebSocket-Key 헤더를 통해 응답을 검증할 키 값을 보낸다.</p>
<h5 id="handshake-response">Handshake Response<a hidden class="anchor" aria-hidden="true" href="#handshake-response">#</a></h5>
<p>요청을 받은 서버는 아래와 같은 응답을 보내주어야 한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-HTTP" data-lang="HTTP"><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">101</span> <span style="color:#a6e22e">Switching Protocols</span>
Upgrade<span style="color:#f92672">:</span> <span style="color:#ae81ff">websocket</span>
Connection<span style="color:#f92672">:</span> <span style="color:#ae81ff">Upgrade</span>
Sec-WebSocket-Accept<span style="color:#f92672">:</span> <span style="color:#ae81ff">s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span>
</code></pre></div><p>Http Status code <strong>101 Switching Protocols</strong></p>
<p>Upgrade 헤더를 통해 요청한 것에 따라 서버가 프로토콜을 바꾼다는 것을 알려주는 응답 코드</p>
<p>서버는 반드시 Sec-WebSocket-Accept 헤더를 명시해서 보내야한다.</p>
<p>클라이언트의 key 값과  &ldquo;<code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>&rdquo; <em>magic string</em> 을 함께</p>
<p>SHA-1 hash 함수로 hashing 한뒤 bash64 로 해쉬값을 인코딩해서 응답을 보낸다</p>
<p>핸드 쉐이크 과정이 끝나면 클라이언트와 서버는 실시간으로 연결된다</p>
<h5 id="data-frame-exchange">Data Frame Exchange<a hidden class="anchor" aria-hidden="true" href="#data-frame-exchange">#</a></h5>
<p>서버와 클라이언트는 data frame 을 통해 데이터를 주고받는다, data frame 은 XOR encryption 으로 마스킹 된다.</p>
<p>데이터 프레임은 아래 구조를 따른다.</p>
<h6 id="data-frame-format">Data Frame Format<a hidden class="anchor" aria-hidden="true" href="#data-frame-format">#</a></h6>
<pre><code> 0               1               2               3
 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 4               5               6               7
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
 8               9               10              11
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
 12              13              14              15
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

</code></pre><p><code>MASK</code> 비트는 메세지가 인코딩 되어있는지 여부를 나타내고,  클라이언트 가 서버에게 보내는 메세지는 항상 마스킹 되어야한다.</p>
<p>서버가 클라이언트에게 보내는 메세지는 항상 마스킹되어 있지 않아야한다 MASK field 0</p>
<p><code>opcode</code> 핖드는 payload 데이터가 어떤 포맷인지 나타낸다.</p>
<p>0x0 continuation, 0x1 text (UTF-8), 0x2 binary</p>
<p>0x3 / 0x7 / 0xB~0xF 의 값은 아무런 의미가 없다.</p>
<p>FIN 비트는 이 메세지가 마지막임을 나타낸다.</p>
<h5 id="payload">Payload<a hidden class="anchor" aria-hidden="true" href="#payload">#</a></h5>
<p>9~15 번 7bit 까지를 읽어 unsigned integer로 취급한 뒤 125이하이면 payload length</p>
<p>126 이면 다음 16 bit 를 읽어 unsigned integer로 처리하고 payload length값으로 사용.</p>
<p>127이면 이면 다음 64bit 를 읽어  unsigned integer로 처리하고 payload length값 으로 사용 <em>최상위 비트는 반드시 0</em></p>
<h4 id="mask">MASK<a hidden class="anchor" aria-hidden="true" href="#mask">#</a></h4>
<p>MASK 비트가 설정되어 있으면 32bit 길이의 Masking-key도 존재한다</p>
<p>Masking-key length 0 or 4 bytes</p>
<p>MASK bit가 1이면 다음 32bit 를 읽는다.</p>
<p>원본 Payload data를 Making-key 의 필드와 MASK[ i % 4] 에 해당하는 1바이트와 XOR 연산을 수행한다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> MASK <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>4<span style="color:#f92672">];</span>
<span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> ENCODED <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>payload<span style="color:#f92672">.</span><span style="color:#a6e22e">legnth</span><span style="color:#f92672">];</span>
<span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> DECODED <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>ENCODED<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span>i<span style="color:#f92672">&lt;</span>ENCODED<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++){</span>
  DECODED<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ENCODED<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">^</span> MASK<span style="color:#f92672">[</span>i<span style="color:#f92672">%</span>4<span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div>
</div>
  <footer class="post-footer">
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://2012monk.github.io/monk">Change of Perceptions</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
