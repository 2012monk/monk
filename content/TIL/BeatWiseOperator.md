## 비트연산자 BeatWiseOperator

---

* **~**  **NOT 연산** *Tilde*

  > `비트 반전(보수) 논리부정 `

  > 이진수로 표현된 피연산자의 값을 반전(보수)시켜주어 표현.

* **' | '    OR 연산** *pipe*

  >`논리합`
  >
  >Bit OR 연산 각두값의 자리를비교해 둘중하나라도 1이 있다면 return 1 아니면 return 0

* **& AND 연산** `Ampersand` 

  >`논리곱`

  > 두 값의 자릿수를 비교해 두 값 모두에 1이 있을때만 return 1

* **^ XOR 연산** *Caret*

  > `배타적 논리합`

  > ​	두 값의 자릿수를 비교해 값이 같으면 1 다르면 0

---

**Bit Shift 연산**

* **<< Left Shift**

> ````java
> x << y  //정수 x의 각 비트를 y만큼 왼쪽으로 이동
> ````
>
>  `x 를 32비트로 분해한 다음 왼쪽으로 y만큼 움직인다`
>
> `이동시 왼쪽비트는 밀려 버려지고 맨 오른쪽은 0 으로 채워진다`

* **>> Right Shift**

> ```java
> x >> y // 정수 x의 각 비트를 y만큼 오른쪽으로 이동
> ```
>
> `x 를 32비트로 분해한 다음 오른쪽으로 y만큼 움직인다`
>
> `이동시 오른쪽 비트는 밀려서 버려지게됨 맨 왼쪽비트는 최상위 부호비트와 동일한 값으로 채워짐`

* **>>>** `오로지 java에만 있는 연산`

> **>>** 연산과 기본원리는 같다
>
> #### *>>* 연산과는 다르게 최상위부호비트와 관계없이  무조건 0으로만 채워지게 된다(무조건 양수로 나옴)

---

### Bitwise assignment operators

> - `x <<= y `  _x 를 y 비트만큼 왼쪽으로_
> -  `<<=`
> - `|=`
> - `&=`
> - `^=`

