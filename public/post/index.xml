<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Change of Perceptions</title>
    <link>https://2012monk.github.io/monk/post/</link>
    <description>Recent content in Posts on Change of Perceptions</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Apr 2021 20:45:53 +0900</lastBuildDate><atom:link href="https://2012monk.github.io/monk/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>I</title>
      <link>https://2012monk.github.io/monk/post/i/</link>
      <pubDate>Thu, 29 Apr 2021 20:45:53 +0900</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/i/</guid>
      <description>#tt</description>
    </item>
    
    <item>
      <title>Tetris rotation</title>
      <link>https://2012monk.github.io/monk/post/til/tetrisrotation/</link>
      <pubDate>Thu, 01 Jan 1970 09:33:41 +0900</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/tetrisrotation/</guid>
      <description>Tetris  Rotation Logic Basically I used SRS Rotation System
  When unobstructed, the tetrominoes all rotate purely about a single point. These apparent rotation centers are shown as circles in the diagram.   Single Point (Pivot) is different by box size (ie 2, 3, 4)
I calculate O block as size of 2 (0, 0), (0, 1), (1, 1), (1, 0)
Box size of I block is 4 and 3 for all other blocks</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/algorithm-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/algorithm-1/</guid>
      <description>BIG-O notaion 참고자료
 big-o 최소 증가율  f(n) = O(g(n))   big-omega 하한 최대 증가율 big-theta 상한과 하한 사이에 존재 (상한, 하한이 같을때는 세타표기법도 같은 증가율)  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/algorithm1/algorithms1_princeton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/algorithm1/algorithms1_princeton/</guid>
      <description>Data structure and Algorithms Union-Find
 Algorithm 설계
Dynamic Connectivity
Array mapping with integers
Equivalence relation(is connected to)
 Reflexive Symmetric Transitive    Quick-find (eager approach)
 O(n^2)    Quick-Union
 O(n)    Quick-Union Improvements
 Merge Trees by Weighting  O(N + lg(N))      </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/algorithm1/dynamicprogramming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/algorithm1/dynamicprogramming/</guid>
      <description>Dynamic Programming 동적계획법  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/beatwiseoperator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/beatwiseoperator/</guid>
      <description>비트연산자 BeatWiseOperator    ~ NOT 연산 Tilde
 비트 반전(보수) 논리부정 
  이진수로 표현된 피연산자의 값을 반전(보수)시켜주어 표현.
   &#39; | &#39; OR 연산 pipe
 논리합
Bit OR 연산 각두값의 자리를비교해 둘중하나라도 1이 있다면 return 1 아니면 return 0
   &amp;amp; AND 연산 Ampersand
 논리곱
  두 값의 자릿수를 비교해 두 값 모두에 1이 있을때만 return 1
   ^ XOR 연산 Caret</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/computer-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/computer-architecture/</guid>
      <description>Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다
각 구성요소는 System Bus 에 의해 연결되어 있다
 System Bus
하드웨어 구성 요소를 물리적으로 연결하는 선
 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/cs-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/cs-memory/</guid>
      <description>Memory Structure 변수 선언 =&amp;gt; 해당 변수 타입으로 메모리를 할당!
 Variable data type 예시   Integer 4byte Long 8byte Float (Single precision) 4byte char (ASCII) 1byte Char[] (String array) 1byte  Memory allocation    SMA(Static memory allocation)
 Data Stack    DMA(Dynamic memory allocation)
 Heap    Code
 명령어(Instruction), 전역 상수 저장 Read only    Data
 프로그램이 실행될때 할당되고 종료될때 해제 BSS(Block Stated Symbol) 영역  초기화 되지 않은 전역변수,string,기타 상수 저장 Rom 사이즈 관리를 위해   Data 영역  초기화 된 전역변수, 정적변수(static) 등으로 선언된 변수 저장 프로그램 실행 중 접근해서 수정,변경 가능       Stack</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/db/r/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/db/r/</guid>
      <description>Relational model  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/git-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/git-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5/</guid>
      <description>GIT 분산형 버전 관리 시스템
참고자료
Progit &amp;ldquo;번역본&amp;rdquo;
  Local repository
  Remote repository
  Git project
 working directory staging area (stage fixes) .git directory(repository) (commit)    Git files
 untracked unmodified modified staged    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/abstract-class-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/abstract-class-interface/</guid>
      <description>Abstract Class, Interface  Abstract class  여러 새로운 클래스를 작성하는데 바탕이 되는 클래스
메소드의 선언부만 작성하고 구현부는 작성하지 않음.
추상클래스 자체로는 인스턴스를 생성하지 못한다. subclass에 의해서만 완성될수 있다
구체적인 클래스의 공통적인 부분을 모아 선언한 클래스
abstract 키워드를 사용해 정의한다
생성자, 필드, 일반메소드 포함가능
메소드 오버라이딩을 강제한다.
  추상화와 구체화를 통해 완성  Inheritance Method overriding    Interface  다중상속이 가능한 일종의 추상 클래스
일반 메소드와 멤버변수를 가질수 없고 추상메소드와 상수만을 멤버로 가질수있다 public static final, public abstract method</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/array-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/array-list/</guid>
      <description>Array vs List  array 같은 타입 변수로 이루어진 유한집합 java Array  각 element 에 index 부여(index는 값에대한 유일무이한 식별자)
연속된 메모리 공간에 할당된다
   장점
 구현이 쉬움 Index가 있어 조회 빠름 O(1) 연속된 메모리공간이라서 순차접근 빠름 참조를 위한 추가 메모리 할당이 필요없음    단점
 삽입, 삭제시 모든 element를 옮겨야됨 크기 고정    List 동적배열 java LinkedList,ArrayList(크기가 가변인 Arrray)  각 element가 다음의 Node를 가르키고 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/class-inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/class-inheritance/</guid>
      <description>상속(Inheritance)   클래스간의 상하 관계 SuperClass 혹은 ParentClass 로부터 SubClass를 만드는것
상속이라는 관계를 통해 계층구조 형성
  접근제어자가 Private일 경우 상속이 불가능하고 defualt일 경우 다른패키지일때 상속이 불가능하다. 패키지가 다를경우 public, protected만 상속 SuperClass 의 필드와 메소드를 물려받는다 새로운 필드 메소드 추가가능 물려받은 메소드 수정가능 Overriding 동일 superclass를 상속하는 모든 subclass는 타입 호환가능. 자바에서 만드는 모든 클래스는 Object 클래스를 자동 상속한다.  클래스 상속은 _extends_키워드를 사용한다.
 다중상속은 지원하지않음.  IS - A 관계 상속관계  IS - A 관계에 있을때 자식객체는 부모 클래스의 자료형인것 처럼 쓸수있다 형변환 type casting  부모클래스 object = new 자식클래스(); 가능 자식클래스 object = new 부모클래스(); 불가능 참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다   자식클래스 Is a 부모클래스  HAS - A 포함관계 composite (포함) 상속이외의 클래스간의 관계</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/constructor-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/constructor-java/</guid>
      <description>Constructor 생성자  initialize instance method 인스턴스변수들을 초기화 1. constructor 의 이름은 class 이름과 같아야한다 2. 리턴 값이 없다 constructor도 overloading 이 가능하므로 여러개 존재가능
 Book b = new Book();	연산자 new 에 의해서 heap에 클래스의 인스턴스 생성
생성자 호출, 수행
생성된 Book인스턴스의 주소가 반환되어 참조변수 b에 저장.
 Default constructor  클래스에 생성자가 하나도 정의 되어 있지 않으면 컴파일러가 자동으로 기본생성자를 추가하여 컴파일한다
ClassName(){}  this() Constructor 호출  this를 사용해 호출 한 생성자에서 다른생성자를 호출시 반드시 첫줄에서만 가능.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/daya-type-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/daya-type-java/</guid>
      <description>Data-Type   참고자료
Primitive Type 실제 data를 저장한다
int 정수형
float 부동소수점
byte 1byte = 8 bit
short 2byte 16bits
double 8byte
long
char
boolean
  기본 자료형   Java에서는 데이터 타입이 명확하지 않을시 기본자료형 적용
 정수형 int
부동소수점 double
 float a = 3.0; //type error 3.0 입력시 자동으로 double형변환 double b = 5 / 4 //b = 1 정수형 입력시 자동으로 int적용  타입 캐스팅 (Casting)  데이터 타입 간에 형변환    float a = (float)0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/exception/</guid>
      <description>Exception 예외처리   Exception Class  RuntimeException IOException    RuntimeException 프로그래머의 실수에 의해 발생될수 있는 예외 Unchecked exception 예외처리를 필수적으로 하지 않아도 compile이 가능하다 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/generics/</guid>
      <description>Generics  generic이란 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일시의 타입체크를 해주는 기능 compile-time type check type안정성을 높이고 형변환의 번거로움을 줄인다 Generic 의 선언 class Name{ Object a; void method(Object a){ this.a = a} } class Name&amp;lt;T&amp;gt;{ T a; void method(T a){this.a = a} } Caret &amp;lt;&amp;gt; 을 통해 선언한다
T는 Type variable라고 하며 임의의 참조형 타입 을 뜻한다
 T가 아닌 다른것을 사용해도 되고 변수타입을 여러개 지정해도 된다.  클래스의 객체를 생성 할때는 타입T Formal type parameter 대신 실제타입Actual type parameter을 지정해주어야 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/io-stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/io-stream/</guid>
      <description>I/O  Input 입력 과 Output 출력
컴퓨터 내부 또는 외부의 장치와 프로그램간 데이터를 주고 받는것.
 Stream  데이터를 전달하기 위해 사용되는 연결통로
연속적인 데이터의 흐름을 물에 비유해서 붙여진 이름이다.
단방향 통신만 가능하기 때문에 input stream 과 output strem 2개의 스트림이 필요하다
중간에 건너뜀 없이 연속적으로 데이터를 주고 받는다. FIFO구조
 IO Stream Input Stream Output Stream  InputStream  java.io.InputStream byte 기반 스트림
java.io.Reader 문자 기반 스트림
This abstract class is the superclass of all classes representing</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/java-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/java-array/</guid>
      <description>Java Array  Array 복사 System.arraycopy(); public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/java-structure-classobjectinstance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/java-structure-classobjectinstance/</guid>
      <description>Java 구조   Class   Java 프로그램은 클래스에서 시작한다
객체를 만들기 위한 설계도
변수와 메서드의 집합 실제 프로그램 안에서 속성은 Field(Member Variable)의 형태로 동작은 Method로 표현.
   Object
 정의 실제로 존재하는 것
속성과 기능의 집합
 Property : member variable, attribute, field, status Function : method, behavior, function     Instance
 클래스를 통해 만들어진 구체적인 객체(JVM 이 관리하는 메모리에 적재된 것)
클래스로 부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/lambda-expression-%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%89%E1%85%B5%E1%86%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/lambda-expression-%E1%84%85%E1%85%A1%E1%86%B7%E1%84%83%E1%85%A1%E1%84%89%E1%85%B5%E1%86%A8/</guid>
      <description>Lambda Expression  method를 하나의 expression으로 표현한것 annoymous function 이라고도 한다
Lambda expression 작성 이름과 반환타입을 제거하고 매개변수 선언부와 몸통사이에 -&amp;gt; 추가
int method(int x){ return x; } (int x) -&amp;gt; x; x -&amp;gt; x*x; // 매개변수가 하나일때는 ()생략 가능. (int y) -&amp;gt; {return 0;} // 몸체가 return만으로 구성되어있으면 {}생략불가 함수형 인터페이스 Functional Interface 추상 메소드를 단 하나만 가지는 interface
람다식은 익명클래스의 객체와 동등하다, 익명 객체의 주소를 f라는 참조변수에 저장해볼때</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/modifier/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/modifier/</guid>
      <description>Modifier 참고자료
 제어자는 클래스, 멤버변수, 메서드에 주로 사용되며 하나에 대상에 대하여 여러 제어자를 조합하여 사용가능. 접근제어자는 네가지중 하나만 사용가능.  Access Modifier  Public, protected, default, private   Other  Static, final, abstract, native, transient, synchronized, volatile, strictfp    Modifier static  class의, 공통적인 Stack memory에 올라간다 Static 변수  클래스가 메모리에 로드될때 생성 Class 변수로서 인스턴스를 생성하지 않고 사용가능 (모든 인스턴스가 공유) class 전역변수   Static method  인스턴스를 생성하지 않고 호출가능 Static method 내에서는 인스턴스멤버를 직접 사용안됨.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/overriding-overloading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/overriding-overloading/</guid>
      <description>Overriding Overloading    Method Overriding  상속관계에 있는 부모클래스에서 정의된 메소드를 자식클래스에서 재정의 chage or modify
자식클래스는 private member를 제외하고 모든 메소드 상속받음
 메소드의 동작만 재정의 =&amp;gt; 선언부가 기존 메소드와 같아야함 접근 제어자를 더 좁은범위로 변경안됨.  부모의 메소드보다 넓은 범위의 접근제어자 지정 해야함   예외범위를 더 크게 선언 안됨. 인스턴스 메소드를 static 메소드로 또는 그반대로 변경불가. 자식 클래스에서 부모의 메소드를 수정할때  추상클래스, 인터페이스에서 필수적으로 사용   부모 메소드 은닉, 재정의된 메소드만 호출 super.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/printstream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/printstream/</guid>
      <description>Java 출력 print  java.io.PrintStream System.out.print(); // 줄바꿈이 되지않는 출력 System.out.println(); // 줄바꿈이 되는 출력 System.out.printf(format, argument); // pinrt format  printf format 서식 지정자나 서식문자가 들어간문자열 (형식문자 | Format Character) 서식지정자(Format Splicer) Class Formatter     Splicer type      %b true/false Boolean 출력   %c Character Char 문자 1개 출력   %t Date,time 날짜 출력 %td,m,h,y,F   %f Float 부동 소수점 10진수 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/referece-type-variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/referece-type-variable/</guid>
      <description>Reference type  기본형 (Primitive type)변수를 제외한 모든 변수 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address) 를 값으로 갖는다. c언어와 달리 참조형 변수 간에 연산 불가능. 참조형 변수는 null 또는 객체의 주소를 값으로 갖는다( null 은 어떤 객체의 주소도 가지고 있지 않음)
String s = new String(&amp;#34;Hello Wolrd!&amp;#34;) Stack 메모리에 s라는 참조변수 생성, new 연산자로 &amp;ldquo;Hello World&amp;quot;를 Heap 메모리할당하여 s에게 리턴
String Class String s1 = &amp;#34;123&amp;#34; String s2 = &amp;#34;123&amp;#34; String s3 = new String(&amp;#34;123&amp;#34;) String s4 = new String(&amp;#34;123&amp;#34;) s1 == s2 // true s1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/servlet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/servlet/</guid>
      <description>Java Servlet  웹페이지를 &#39;동적&#39;으로 생성하는 ServerSide program
 웹 서버 성능을 향상하기 위해 사용하는 자바 클래스의 일종.
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/string-class/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/string-class/</guid>
      <description>Java String Class  String 클래스는 java.lang 패키지에 포함되어있는 클래스이다.
다른 언어에서는 문자열을 char형 배열로 표현하지만 자바에서는 String이라는 클래스를 별도로 제공한다.
모든 스트링 리터럴은 string class의 인스턴스이다. 인스턴스 생성시 인스턴스 변수 value 에 문자형 배열char[] 이 저장된다.
string은 서로 공유될수 있기때문에 String 의 값은 변경 불가능하다. immutable
String str = &amp;#39;abc&amp;#39; // 위 아래는 같다 char data[] = {&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;}; String str = new String(data); String buffer 클래스는 변경가능한 string 을 지원한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/java/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/java/thread/</guid>
      <description>Thread  Process &amp;amp; Thread Process  컴퓨터에서 연속적으로 실행되고 있는 프로그램 운영체제의 최소 작업 단위
 프로그램 파일이 저장장치에 저장되어 있지만 메모리에는 올라가있지 않은 정적인 상태
프로세스 프로그램이 실행되어 메모리에 올라간 동적인 상태
 프로그램을 실행하면 시스템 자원을 할당받아 프로세스가 된다 프로그램의 인스턴스
시스템 자원
 독립된 메모리공간 cpu시간 운영되기 위해 필요한 메모리 주소  프로세스마다 독립된 메모리 영역을 할당하기에 한 프로세스는 다른 프로세스에 접근할수없다.
 운영체제의 안정성을 위해 프로세스마다 할당된 메모리 내부 정보만 접근가능하게 제약하고 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/oop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/oop/</guid>
      <description>Object Oriented Programming 객체 지향 프로그래밍  OOP Concept  &#39;실제 세계는 객체로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.&#39; 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 객체의 모임으로 보고자하는 패러다임  객체지향언어  객체지향언어의 장점  Strong Cohesion and Weak Coupling  코드의 재사용성이 높다 Resuable
코드의 유지보수가 쉽다
 Weak Coupling  클래스간 독립적 디자인으로 결합력을 약하게 할수있다 프로그램을 독립적으로 볼수 있기때문    신뢰성이 높은 프로그래밍이 가능</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/readme/</guid>
      <description>TIL The Change of Perception</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/terms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/terms/</guid>
      <description>Library Framework Package Module  module
 특정 기능을 하는 컴퓨터 시스템이나 프로그램의 단위
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/uml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/uml/</guid>
      <description>UML Unified Modeling Language  객체지향설계시에 사용되는 일반적인 모델링 언어 UML을 사용하면 작성전에 구현하고자 하는 시스템을 시각화하여 검토 가능 Class name
 Class field
 -a: int
+b:int
 - private
+ public
# protected
/ derived
~ package
   Class method
   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/untitled-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/untitled-1/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/untitled/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/untitled/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/db-normalizaion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/db-normalizaion/</guid>
      <description>Database Normalization   관계형 데이터베이스의 설계에서 중복을 최소화 하게 데이터를 구조화하는 프로세스
정규화를 통해 불필요한 데이터를 없앨 수 있고 각종 이상현상을 방지한다
정규화의 목적은 하나의 테이블에서의 데이터의 삽입,삭제,변경이 정의된 관계들로 인하여 데이터베이스의 나머지 부분들로 전파되게 하는 것
  불필요한 데이터 제거
  논리적인 데이터 저장
   충분히 정규화가 되지 않은 구조의 테이블 수정시에 부작용이 발생할수 있다
 같은 정보가 복수개의 행에서 표현된다. 하나의 정보를 수정시에 전체수정 갱신이상 어떠한 특정 사실은 기록되지 않음 삽입이상 데이터의 삭제가 전혀다른 데이터의 삭제도 필요로 하게된다 삭제이상  1NF 1차 정규화 각 로우마다 컬럼의 값이 1개씩만 있어야 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/http/</guid>
      <description>HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜
Client-Server Protocol
request response  메세지로 이루어진다.
  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response
이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/https/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/https/</guid>
      <description>HTTPS Hyper Text Transfer Protocol over Secure Socket Layer   HTTP over TLS HTTP over SSL
HTTP 프로토콜의 보안이 강화된 버전
SSL/TLS 프로토콜을 통해 세션 데이터를 암호화 한다
기본 포트 443
 TLS / SSL  Transport Layer Security TLS
Secure Sockets Layer SSL
통신 보안을 제공하기 위해 설계된 암호규약
TLS 는 SSL 이 표준화 되면서 바뀐이름이다 TLS 는 SSL3.0 을 계승한다
TCP/IP 위에서 적용되며 end to end 보안과 데이터 무결성을 확보한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/mqtt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/mqtt/</guid>
      <description>MQTT Message Queuing Telemetry Transport   TCP/IP protocol 위에서 동작하는 발행-구독 기반의 messaging protocol
Message broker 가 필요하다
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/osi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/osi/</guid>
      <description>OSI  Open Systems Interconnection Reference Model 개방형 시스템간 상호접속 참조 모델  OSI 모형이란? 국제표준화기구 ISO 에서 개발한 모델로써 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한것이다.
 프로토콜이란 FTP(File Transfer Protocol) 일반적으로 줄여서 프로토콜이라 부르며
어떤 시스템이라도 네트워크 유형에 관계없이 상호 통신 가능한 지침, 신뢰성있고 원활한 통신을 위해 서로 합의에 의해 설정한 통신규약
신호 송신의 순서, 데이터의 표현법, 오류 검출법 등을 포함하고있다.
 과거 여러 통신 업체들의 상호 이질적인 네트워크간의 연결에 호환성 결여를 막기위해 제시된 모델이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/udp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/udp/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/was/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/was/</guid>
      <description>Web application server    DBMS database management system
 다수의 사용자가 데이터베이스 내의 데이터에 접근할수 있도록 하는 소프트웨어
 클라이언트와 직접 연결되어 작동 로직변경시 클라이언트 재배포 필요     MiddleWare
 클라이언트와 Database 사이에 서버(middleware)를 두는 방식
 로직을 middleware 서버에서 동작하게 함으로 클라이언트는 입,출력만 담당     WAS Web Application Server
 일종의 미들웨어, 웹클라이언트의 요청중 보통 웹 애플리케이션이 동작하도록 지원
 프로그램 실행환경, 데이터베이스 접속 기능 여러개의 트랜잭션 관리 비즈니스 로직수행 웹서버의 기능도 기본적으로 제공     Web Server vs WAS</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/websocket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/websocket/</guid>
      <description>WebSocket  HTTP protocol  HTTP 프로토콜은 request, response 라는 message에 의해 성립된다
Stateless protocol 이기 때문에 통신이 끝나면 통신을 유지하지 않고 끊는다
 HTTP protocol 의 방식은 서버측 데이터가 업데이트 되더라도 요청에대한 응답만 보낼수 있기때문에 클라이언트가 요청하기 전에 실시간으로 반영 하기 힘들다. 이러한 방식은 문서 교환 이외의 실시간 통신이 필요한 서비스의 수요를 충족하기엔 힘들었고, 매 요청 연결을 만들고 끊는 과정을 반복 (이러한 과정은 자원이 많이 소모된다 ) 하는 비효율성에 대한 문제가 있었다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/web/xmpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/web/xmpp/</guid>
      <description>XMPP Extensible Messaging and Presence Protocol   확장가능한 메시징과 상태를 위한 규격
XML 에 기반한 메시지 지향 미들웨어용 통신 프로토콜이다.
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://2012monk.github.io/monk/post/til/websocket-%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9-%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC-%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/websocket-%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9-%E1%84%8E%E1%85%A2%E1%84%90%E1%85%B5%E1%86%BC-%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/</guid>
      <description>WebSocket 으로 구현한 채팅   chat Private chat Room chat login Add friend   Socket 을 활용한 채팅 app 구현을 하고난 뒤 웹에서 채팅을 구현 하려고 하였습니다.
소켓 통신과는 달리 http 프로토콜 에서는 통신 연결의 유지가 힘들다는 점에서 좌절을 느끼고 다른 방법을 찾아보았습니다
여러가지 방법 polling, longpolling 등 방식이 있었지만 소켓의 연결이 유지되는 web socket 으로 채팅을 구현하였습니다.
Login 로그인 방식은 서버 세션으로 구현했습니다.
HttpSession 객체에 임의의 세션아이디를 부여하고 DB와 연동함으로써 서버가 다운되더라도 유지될수 있도록 구현했습니다.</description>
    </item>
    
    <item>
      <title>test</title>
      <link>https://2012monk.github.io/monk/post/til/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://2012monk.github.io/monk/post/til/test/</guid>
      <description>TestStart   somthing somthing1
  </description>
    </item>
    
  </channel>
</rss>
