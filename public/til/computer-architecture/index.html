<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Change of Perceptions</title><meta name=keywords content><meta name=description content="Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다
각 구성요소는 System Bus 에 의해 연결되어 있다
 System Bus
하드웨어 구성 요소를 물리적으로 연결하는 선
 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다"><meta name=author content><link rel=canonical href=https://2012monk.github.io/monk/til/computer-architecture/><link crossorigin=anonymous href=/monk/assets/css/stylesheet.min.65aebb33e4f0ce3d1a39e4a35c11b91eb08b582489fca0f78f9227d90ac72a52.css integrity="sha256-Za67M+Twzj0aOeSjXBG5HrCLWCSJ/KD3j5In2QrHKlI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/monk/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://2012monk.github.io/monk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2012monk.github.io/monk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2012monk.github.io/monk/favicon-32x32.png><link rel=apple-touch-icon href=https://2012monk.github.io/monk/apple-touch-icon.png><link rel=mask-icon href=https://2012monk.github.io/monk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content><meta property="og:description" content="Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다
각 구성요소는 System Bus 에 의해 연결되어 있다
 System Bus
하드웨어 구성 요소를 물리적으로 연결하는 선
 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다"><meta property="og:type" content="article"><meta property="og:url" content="https://2012monk.github.io/monk/til/computer-architecture/"><meta property="article:section" content="TIL"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다
각 구성요소는 System Bus 에 의해 연결되어 있다
 System Bus
하드웨어 구성 요소를 물리적으로 연결하는 선
 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"TILs","item":"https://2012monk.github.io/monk/til/"},{"@type":"ListItem","position":3,"name":"","item":"https://2012monk.github.io/monk/til/computer-architecture/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다\n각 구성요소는 System Bus 에 의해 연결되어 있다\n System Bus\n하드웨어 구성 요소를 물리적으로 연결하는 선\n 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다","keywords":[],"articleBody":"Computer architecture   컴퓨터의 구성요소는 CPU Memory I/O 으로 이루어져있다\n각 구성요소는 System Bus 에 의해 연결되어 있다\n System Bus\n하드웨어 구성 요소를 물리적으로 연결하는 선\n 주소버스 address bus  기억장치의 주소 또는 입출력장치의 포트를 전달 cpu에서 memory, i/o 으로 memory address를 전달하기때문에 단방향 버스이다 주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수   데이터 버스 Data bus  Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 양방향 버스이다   제어 버스 Control bus  CPU에서 제어신호를 전달한다    CPU central processing unit 중앙처리장치  구성요소  register 산술논리장치 arithmetic logic unit ALU Control unit Internal Bus  Register 레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 word 워드 이다\ncpu의 속도와 비슷한 고속 memory, 명령어 세트,연산에 필요한데이터, 연산결과를 임시로 저장한다.\n범용 레지스터와 특수목적 레지스터로 나누어진다.\nGeneral purpose register 연산에 필요한 데이터나 연산결과를 임시로 저장한다 연산에 특화된 레지스터\n Accumlator 누산기 연산결과를 임시적으로 저장한다  Special purpose register 범용 이외의 다른 registers 각각 다른 기능에 특화\nInstruction\n PC : Program counter   다음 인출할 instruction memory address 를 임시로 저장하고\n각 명령어 인출 후에는 1씩 증가한다\n  IR : Instruction Register   현재 실행중인 명령어를 임시로 저장한다.\ncpu가 IR에 있는 명령어를 decoding 하고 제어신호를 발생\n DATA, Address\n  Adress register\n  주소 버스에 주소를 출력하기 전에 저장하는 레지스터\n  주소 버스의 선에 주소 레지스터의 출력선이 직접 접속된다\n   MAR Memory adress register\n주기억장치의 메모리주소를 저장\n    Stack pointer\nStack memry에 데이터가 채워진 마지막 위치를 가르킨다\n    Base Pointer\n    Index register\n     Data Register 데이터 레지스터\n MBR : Memory buffer register    PSR Program status register\n cpu의 현재상태를 저장한다.  동작 구조 Instruction Cycle Operation Set 명령어 세트\n명령어 세트는 Operatrion code/ Operand 의 조합으로 이루어진다\n Operation code  연산기능 : bitwise operation, 사칙연산등을 수행 제어 기능 : 조건 분기, 무조건 분기등으로 명령어 실행순서 제어 데이터 전달 기능 : 레지스터 사이, cpu와 레지스터사이 데이터를 전달한다. 입출력 기능 : 프로그램과 데이터는 cpu로 연산결과는 I/O으로 전달   Operand 피연산자, 주소필드  Address : 기억장치, 레지스터의 주소 Number/ character : 숫자는 각각의 주소로 문자는 아스키 코드로 저장 Boolean : bit 나 flag로 저장된다    명령어 사이클을 세분화하면 인출, 실행, 간접, 인터럽트 사이클로 이루어진다.\n무조건 실행되는 사이클은 명령어 인출과 명령어 실행의 과정으로 이루어진다. Fetch/Excution\n Fetch Cycle 인출 단계\nPC 에 저장된 주소를 MAR 에 전달한다\nMAR 에 저장된 내용을 토대로 주기억장치에서 해당 주소에서 명령어를 인출한다\n인출한 명령어를 MBR 에 저장한다\nMBR에 저장된 내용을 IR에 전달한다\nExcution Cycle 실행단계\nIR 에서 MAR 명령어 전달\n기억장치에서 인출후 MBR 에 전달\nMBR 에서 ALU AC 에 전달한다\nIndirection Cycle 간접단계\n인출단계에서 가져온 명령어의 주소부가 간접 주소인경우 간접단계로 넘어온다\n유효주소를 가져오기위해 실행되는 단계이다\nIntterupt Cycle 인터럽트 단계\n실행중 인터럽트가 발생되었을때 실행되는 단계이다.\n원래의 명령을 수행하다 인터럽트가 발생되었을때 복귀주소를 지정하고 인터럽트 상태를 해소 하고 돌아와 메인 명령을 다시 수행한다.\n그래서 서브루틴 Subroutine 부프로그램 이라고도 부른다.\n ","wordCount":"437","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://2012monk.github.io/monk/til/computer-architecture/"},"publisher":{"@type":"Organization","name":"Change of Perceptions","logo":{"@type":"ImageObject","url":"https://2012monk.github.io/monk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://2012monk.github.io/monk accesskey=h title="Change of Perceptions (Alt + H)">Change of Perceptions</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://2012monk.github.io/monk/categories/ title=categories><span>categories</span></a></li><li><a href=https://2012monk.github.io/monk/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title></h1><div class=post-meta></div></header><div class=post-content><h3 id=computer-architecture>Computer architecture<a hidden class=anchor aria-hidden=true href=#computer-architecture>#</a></h3><hr><blockquote><p>컴퓨터의 구성요소는 <code>CPU Memory I/O</code> 으로 이루어져있다</p><p>각 구성요소는 <code>System Bus</code> 에 의해 연결되어 있다</p></blockquote><p><code>System Bus</code></p><p><em>하드웨어 구성 요소를 물리적으로 연결하는 선</em></p><ul><li>주소버스 <code>address bus</code><ul><li>기억장치의 주소 또는 입출력장치의 포트를 전달</li><li>cpu에서 memory, i/o 으로 memory address를 전달하기때문에 <em>단방향</em> 버스이다</li><li>주소 선의 수는 시스템의 기억장치 용량을 결정한다 bit단위 한번에 읽어 올수있는 비트수</li></ul></li><li>데이터 버스 <code>Data bus</code><ul><li>Memory, I/O 의 명령어나 데이터를 CPU로 CPU의 연산결과를 Memory, I/O 으로 전달하기에 <em>양방향</em> 버스이다</li></ul></li><li>제어 버스 <code>Control bus</code><ul><li>CPU에서 제어신호를 전달한다</li></ul></li></ul><h3 id=cpu-central-processing-unit-중앙처리장치>CPU <code>central processing unit</code> 중앙처리장치<a hidden class=anchor aria-hidden=true href=#cpu-central-processing-unit-중앙처리장치>#</a></h3><hr><h4 id=구성요소>구성요소<a hidden class=anchor aria-hidden=true href=#구성요소>#</a></h4><ul><li><code>register</code></li><li>산술논리장치 <code>arithmetic logic unit ALU</code></li><li><code>Control unit</code></li><li><code>Internal Bus</code></li></ul><h4 id=register>Register<a hidden class=anchor aria-hidden=true href=#register>#</a></h4><p>레지스터의 비트수는 cpu 1회 연산에 처리가 가능한 데이터 비트 수 <code>word 워드</code> 이다</p><p>cpu의 속도와 비슷한 고속 memory, 명령어 세트,연산에 필요한데이터, 연산결과를 임시로 저장한다.</p><p>범용 레지스터와 특수목적 레지스터로 나누어진다.</p><p><code>General purpose register</code> 연산에 필요한 데이터나 연산결과를 임시로 저장한다 연산에 특화된 레지스터</p><ul><li><code>Accumlator</code> 누산기 연산결과를 임시적으로 저장한다</li></ul><p><code>Special purpose register</code> 범용 이외의 다른 registers 각각 다른 기능에 특화</p><p>Instruction</p><ul><li><code>PC : Program counter</code></li></ul><blockquote><p>다음 인출할 instruction memory address 를 임시로 저장하고</p><p>각 명령어 인출 후에는 1씩 증가한다</p></blockquote><ul><li><code>IR : Instruction Register</code></li></ul><blockquote><p>현재 실행중인 명령어를 임시로 저장한다.</p><p>cpu가 IR에 있는 명령어를 decoding 하고 제어신호를 발생</p></blockquote><p>DATA, Address</p><ul><li><p>Adress register</p><ul><li><p>주소 버스에 주소를 출력하기 전에 저장하는 레지스터</p></li><li><p>주소 버스의 선에 주소 레지스터의 출력선이 직접 접속된다</p></li><li><blockquote><p><code>MAR</code> <code>Memory adress register</code></p><p>주기억장치의 메모리주소를 저장</p></blockquote></li><li><blockquote><p><code>Stack pointer</code></p><p>Stack memry에 데이터가 채워진 마지막 위치를 가르킨다</p></blockquote></li><li><blockquote><p><code>Base Pointer</code></p></blockquote></li><li><blockquote><p><code>Index register</code></p></blockquote></li></ul></li><li><p><code>Data Register</code> 데이터 레지스터</p><ul><li><code>MBR : Memory buffer register</code></li></ul></li></ul><p><code>PSR Program status register</code></p><ul><li>cpu의 현재상태를 저장한다.</li></ul><h4 id=동작-구조-instruction-cycle>동작 구조 <code>Instruction Cycle</code><a hidden class=anchor aria-hidden=true href=#동작-구조-instruction-cycle>#</a></h4><p><code>Operation Set</code> 명령어 세트</p><p>명령어 세트는 <code>Operatrion code/ Operand</code> 의 조합으로 이루어진다</p><ul><li><code>Operation code</code><ul><li>연산기능 : bitwise operation, 사칙연산등을 수행</li><li>제어 기능 : 조건 분기, 무조건 분기등으로 명령어 실행순서 제어</li><li>데이터 전달 기능 : 레지스터 사이, cpu와 레지스터사이 데이터를 전달한다.</li><li>입출력 기능 : 프로그램과 데이터는 cpu로 연산결과는 I/O으로 전달</li></ul></li><li><code>Operand</code> <em>피연산자, 주소필드</em><ul><li>Address : 기억장치, 레지스터의 주소</li><li>Number/ character : 숫자는 각각의 주소로 문자는 아스키 코드로 저장</li><li>Boolean : bit 나 flag로 저장된다</li></ul></li></ul><p>명령어 사이클을 세분화하면 인출, 실행, 간접, 인터럽트 사이클로 이루어진다.</p><p>무조건 실행되는 사이클은 명령어 인출과 명령어 실행의 과정으로 이루어진다. <code>Fetch/Excution</code></p><blockquote><p><code>Fetch Cycle</code> 인출 단계</p><p><code>PC</code> 에 저장된 주소를 <code>MAR</code> 에 전달한다</p><p><code>MAR</code> 에 저장된 내용을 토대로 주기억장치에서 해당 주소에서 명령어를 인출한다</p><p>인출한 명령어를 <code>MBR</code> 에 저장한다</p><p><code>MBR</code>에 저장된 내용을 <code>IR</code>에 전달한다</p><p><code>Excution Cycle</code> 실행단계</p><p><code>IR</code> 에서 <code>MAR</code> 명령어 전달</p><p>기억장치에서 인출후 <code>MBR</code> 에 전달</p><p><code>MBR</code> 에서 <code>ALU</code> <code>AC</code> 에 전달한다</p><p><code>Indirection Cycle</code> 간접단계</p><p>인출단계에서 가져온 명령어의 주소부가 간접 주소인경우 간접단계로 넘어온다</p><p>유효주소를 가져오기위해 실행되는 단계이다</p><p><code>Intterupt Cycle</code> 인터럽트 단계</p><p>실행중 인터럽트가 발생되었을때 실행되는 단계이다.</p><p>원래의 명령을 수행하다 인터럽트가 발생되었을때 복귀주소를 지정하고 인터럽트 상태를 해소 하고 돌아와 메인 명령을 다시 수행한다.</p><p>그래서 서브루틴 <code>Subroutine</code> 부프로그램 이라고도 부른다.</p></blockquote></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://2012monk.github.io/monk>Change of Perceptions</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>