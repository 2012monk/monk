<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Change of Perceptions</title><meta name=keywords content><meta name=description content="HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜
Client-Server Protocol
request response  메세지로 이루어진다.
  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response
이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다"><meta name=author content><link rel=canonical href=https://2012monk.github.io/monk/til/web/http/><link crossorigin=anonymous href=/monk/assets/css/stylesheet.min.65aebb33e4f0ce3d1a39e4a35c11b91eb08b582489fca0f78f9227d90ac72a52.css integrity="sha256-Za67M+Twzj0aOeSjXBG5HrCLWCSJ/KD3j5In2QrHKlI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/monk/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://2012monk.github.io/monk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://2012monk.github.io/monk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://2012monk.github.io/monk/favicon-32x32.png><link rel=apple-touch-icon href=https://2012monk.github.io/monk/apple-touch-icon.png><link rel=mask-icon href=https://2012monk.github.io/monk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.1"><meta property="og:title" content><meta property="og:description" content="HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜
Client-Server Protocol
request response  메세지로 이루어진다.
  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response
이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다"><meta property="og:type" content="article"><meta property="og:url" content="https://2012monk.github.io/monk/til/web/http/"><meta property="article:section" content="TIL"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜
Client-Server Protocol
request response  메세지로 이루어진다.
  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response
이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"TILs","item":"https://2012monk.github.io/monk/til/"},{"@type":"ListItem","position":3,"name":"","item":"https://2012monk.github.io/monk/til/web/http/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜\nClient-Server Protocol\nrequest response  메세지로 이루어진다.\n  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response\n이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다","keywords":[],"articleBody":"HTTP hyper-text transfer protocol   HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜\nClient-Server Protocol\nrequest response  메세지로 이루어진다.\n  connectionless  request를 서버에 보내면 response이후 접속을 끊는다 HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다   stateless  통신이 끝나면 상태를 유지하지 않는다. 상태 정보를 유지하지 않는다    structure  HTTP는 요청과 응답으로 이루어진다 Request Response\n이런 요청사이 Client 와 Server 에는 여러가지 개체들이 있다\nGateway / proxy\n HTTP Header headers 는 클라이언트와 서버에 추가적인 정보를 제공해준다\n General Header   두가지 요소로 이루어 져있다 request response\n  Request Header   조금더 많은 정보를 가지고 있다\nresponse 에서 불러올 fetch 정보들\n클라이언트에 의한 서버로 요청 request\n  Response Header   서버로 보낼 Response 정보가 조금더 담겨있다\n  Entitiy Header   Body 에 있는 정보\n ","wordCount":"115","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://2012monk.github.io/monk/til/web/http/"},"publisher":{"@type":"Organization","name":"Change of Perceptions","logo":{"@type":"ImageObject","url":"https://2012monk.github.io/monk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://2012monk.github.io/monk accesskey=h title="Change of Perceptions (Alt + H)">Change of Perceptions</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://2012monk.github.io/monk/categories/ title=categories><span>categories</span></a></li><li><a href=https://2012monk.github.io/monk/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title></h1><div class=post-meta></div></header><div class=post-content><h2 id=http-hyper-text-transfer-protocol>HTTP <code>hyper-text transfer protocol</code><a hidden class=anchor aria-hidden=true href=#http-hyper-text-transfer-protocol>#</a></h2><hr><blockquote><p>HTTP 는 웹에서 이루어 지는 모든 데이터 교환의 기초 이자 리소스를 가져올 수 있도록 해주는 프로토콜</p><p><code>Client-Server Protocol</code></p><p><code>request</code> <code>response</code> 메세지로 이루어진다.</p></blockquote><ul><li><code>connectionless</code><ul><li>request를 서버에 보내면 response이후 접속을 끊는다</li><li>HTTP1.1에서는 keep-alive값으로 커넥션을 재활용 한다</li></ul></li><li><code>stateless</code><ul><li>통신이 끝나면 상태를 유지하지 않는다. <em>상태 정보를 유지하지 않는다</em></li></ul></li></ul><h4 id=structure>structure<a hidden class=anchor aria-hidden=true href=#structure>#</a></h4><blockquote><p>HTTP는 요청과 응답으로 이루어진다 <code>Request</code> <code>Response</code></p><p>이런 요청사이 <em>Client 와 Server</em> 에는 여러가지 개체들이 있다</p><p>Gateway / proxy</p></blockquote><h4 id=http-header>HTTP Header<a hidden class=anchor aria-hidden=true href=#http-header>#</a></h4><p><em>headers 는 클라이언트와 서버에 추가적인 정보를 제공해준다</em></p><ul><li>General Header</li></ul><blockquote><p>두가지 요소로 이루어 져있다 <code>request response</code></p></blockquote><ul><li>Request Header</li></ul><blockquote><p>조금더 많은 정보를 가지고 있다</p><p>response 에서 불러올 fetch 정보들</p><p>클라이언트에 의한 서버로 요청 request</p></blockquote><ul><li>Response Header</li></ul><blockquote><p>서버로 보낼 Response 정보가 조금더 담겨있다</p></blockquote><ul><li>Entitiy Header</li></ul><blockquote><p>Body 에 있는 정보</p></blockquote></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://2012monk.github.io/monk>Change of Perceptions</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>